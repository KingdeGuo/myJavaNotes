[toc]

# 初始化与清理

- `new`表达式确实返回了对新建对象的引用，但构造器本身没有任何返回值。

- 如果传入的数据类型（实际参数的类型）小于方法中声明的形式参数类型，实级数据类型 就会被提升。

- `char`略有不同，如果无法找到恰好接收`char`参数的方法，就会把`char`直接提升为`int`型。

- 如果方法接受较小的基本类型作为参数，如果传入的实级参数较大，就会通过类型转化来执行窄化转化，如果不这样做，编译器就会报错。

- 代码示例

  ```java
  //: initialization/Apricot.java
  public class Apricot {
    void pick() { /* ... */ }
    void pit() { pick(); /* ... */ }
  } ///:~
  ```

  `this`关键字只能在方法内部使用，表示“调用方法的那个对象”。

  `this`关键字对于将当前对象传递给其他方法很有用

  ```java
  //: initialization/PassingThis.java
  
  class Person {
    public void eat(Apple apple) {
      Apple peeled = apple.getPeeled();
      System.out.println("Yummy");
    }
  }
  
  class Peeler {
    static Apple peel(Apple apple) {
      // ... remove peel
      return apple; // Peeled
    }
  }
  
  class Apple {
    Apple getPeeled() { return Peeler.peel(this); }
  }
  
  public class PassingThis {
    public static void main(String[] args) {
      new Person().eat(new Apple());
    }
  } /* Output:
  Yummy
  *///:~
  ```

  

- 编译器暗自把所有操作对象的引用作为第一个参数传递给`peel()`。

- `static`就是没有`this`的方法。在`static`内部不能调用非静态方法。

- 使用`static`方法时，由于不存在`this`，所以不是通过“向对象发送消息”的方式来完成设计的。因此，如果出现了大量的`static`方法，就要重新考虑自己的设计了。




## 垃圾回收部分

- 垃圾回收器只知道释放那些经由`new`分配的内存，但是不知道该如何释放该对象的这块“特殊”的内存。为了应对这种情况，Java允许在类中定义一个`finalize()`的方法。它的工作原理是这样的：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其`finalize()`方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以你要是打算用`finalize()`，就能在垃圾回收时刻做一些重要的清理工作。
- 需要明确的三个关键点
  - 对象可能不被垃圾回收
  - 垃圾回收并不等于析构
  - 垃圾回收只与内存有关
- 使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。
- 无论是“垃圾回收”还是“终结”，都不保证一定会发生，如果Java虚拟机（JVM）并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。
- `finalize()`还有一个有趣的用法，它并不依赖于每次都要对`finalize()`进行调用，这就是对象终结条件的验证。
- 你应该总是假设积累版本的`finalize()`也要做某些重要的事情，因此要使用`super`来调用它。
- 如何判断是否为垃圾
  - 采用**引用-计数**的方式
    - 当引用离开作用域或者被置为null时，引用计数减1.
    - 如果出现循环引用将无法被标记
  - 另一种方式的思想：对于任意一种“活”着的对象，一定能追溯到其存活在堆栈活静态存储区之中的引用。这条引用链可能会穿过数个对象层次，由此，如果从堆栈和静态存储区域开始，遍历所有的引用，就能找到所有活的对象。
- 在这种方式下，Java采用一种自适应的垃圾回收技术。
  - **停止-复制**：将所有活的对象从当前堆复制到另一个堆，没有被复制的全部都是垃圾，当对象被复制到新堆时，它们是一个挨着一个的，所有新堆保持紧凑排列。
    - 效率低，需要在两个额外的堆之间来回倒腾。一种办法是按需从堆中分出几块比较大的内存，复制动作发生在这些大块内存之间。
    - 当垃圾很少时，这样做会很浪费。
  - **标记-清扫**：从堆栈和静态存储区域出发，遍历所有的引用，进而找出所有的对象。每当找到一个存活的对象，就给对象设一个标记，这个过程不会回收任何对象。只有当全部标记工作完成时清理工作才会开始。
    - 剩下的空间是不连续的，如果希望得到连续的空间，就得重新整理剩下的对象。
    - 要是堆空间出现了很多碎片，就会按照停止-复制的方式来执行。
  - 在某些Java虚拟机中，内存分配以“块”为单位。如果对象比较大，就会占用单独的块。每个块都有相应的代数来记录它是否还存活。如果块在某处被引用，其代数会增加。
- JIT值“即时”编译技术。这种技术可以把全部程序或部分翻译成本地机器码（这本来是Java虚拟机的工作）。
  - 当需要装载某个类时时，编译器会找到其class文件，然后将该类的字节码装入内存，此时有两种方式可供选择
    - 一种是让即时编译器编译所有代码。	
      - 不足之处1：加载动作散落在整个程序生命周期内，累计起来花费时间很长
      - 不足之处2：会增加可执行代码长度（字节码要比及时编译器展开后的本地代码小很多），因此这可能会导致页面调度，降低了程序速度。
    - 另一种方式的惰性评估。即编译器只在必要时才编译代码。代码每次执行的时候都会做一些优化，因此执行的次数越多，它的速度就越快。
- 91