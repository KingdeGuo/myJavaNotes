[toc]

# 面向对象部分拾遗

- 多态：程序定义的引用变量所指向是具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定。即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能确定。

- Java面向对象三大特性

  - 封装
  - 继承
  - 多态

- 方法重载实现的是编译时的多态性，也就是前绑定，而方法重写实现的是运行时多态，也成为后绑定。

- Java实现多态的三个必要条件

  - 继承
  - 重写
  - 向上转型

- 面向对象五大原则

  - 单一接口原则
  - 开放封闭原则
  - 里氏替换原则
  - 依赖倒置原则
  - 接口分离原则

- 抽象类与接口的对比

  - 从设计上来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。
  - 相同点
    - 都不能实例化
    - 都位于继承的顶端，用于被其他实现或者继承
    - 都包含抽象方法，其子类都必须复写这些抽象方法
  - 不同点
    - 声明所使用的关键字不同：分别是`abstract`和`interface`
    - 实现时所使用的关键字不同，分别是`extends`和`implements`
    - 抽象类可以有构造器，接口不能有构造器
    - 抽象类中的方法可以是任意访问修饰符，接口中默认使用`public`，其不能使用`private`或者`protected`
    - 一个类最多直能继承一个类，但是可以实现多个接口
    - 抽象类字段声明可以是任意的，接口字段默认都是`final`和`static`的。
  - 行为模型应该总是定义接口而不是抽象类
  - 选择抽象类时一般用于一下情况：需要定义子类的行为，又要为子类提供通用的功能。

- 抽象类不能使用`final`，如果定义为`final`该类就不能被继承，这样会产生矛盾。

- 什么是内部类

  内部类就是在类的内部再定义一个类。内部类本身就是类的一个属性，与其他属性定义方式一致。

- 内部类有四种

  - 静态内部类
    - 调用方式：`new 外部类.静态内部类()`
  - 成员内部类
    - 调用方式：`外部实例类.new 内部类()`
  - 局部内部类
    - 调用方式：`new 内部类`
  - 匿名内部类
    - 调用方式：`new 类名{ //匿名内部类实现部分  }`

- 内部类的优点

  - 内部类可以访问创建它的外部类对象的所有内容，包括私有数据。
  - 内部类不为同一个包中的其他类所见，具有良好的封装性
  - 内部类有效的实现了“多重继承”
  - 匿名内部类可以方便的实现回调。

- 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须加上`final`

  这是因为声明周期不一致导致的，局部变量直接存储再栈中，当方法执行结束后，非`final`的局部变量就会被销毁，而局部内部类对局部变量的引用仍然存在，如果局部内部类要调用局部变量时，就会出错。加上`final`之后，可以确保局部内部类使用的变量与外层的局部变量分开，解决了这个问题。

- 