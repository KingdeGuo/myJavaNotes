[toc]

# 面向对象部分拾遗

- 多态：程序定义的引用变量所指向是具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定。即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能确定。

- Java面向对象三大特性

  - 封装
  - 继承
  - 多态

- 方法重载实现的是编译时的多态性，也就是前绑定，而方法重写实现的是运行时多态，也成为后绑定。

- Java实现多态的三个必要条件

  - 继承
  - 重写
  - 向上转型

- 面向对象五大原则

  - 单一接口原则
  - 开放封闭原则
  - 里氏替换原则
  - 依赖倒置原则
  - 接口分离原则

- 抽象类与接口的对比

  - 从设计上来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。
  - 相同点
    - 都不能实例化
    - 都位于继承的顶端，用于被其他实现或者继承
    - 都包含抽象方法，其子类都必须复写这些抽象方法
  - 不同点
    - 声明所使用的关键字不同：分别是`abstract`和`interface`
    - 实现时所使用的关键字不同，分别是`extends`和`implements`
    - 抽象类可以有构造器，接口不能有构造器
    - 抽象类中的方法可以是任意访问修饰符，接口中默认使用`public`，其不能使用`private`或者`protected`
    - 一个类最多直能继承一个类，但是可以实现多个接口
    - 抽象类字段声明可以是任意的，接口字段默认都是`final`和`static`的。
  - 行为模型应该总是定义接口而不是抽象类
  - 选择抽象类时一般用于一下情况：需要定义子类的行为，又要为子类提供通用的功能。

- 抽象类不能使用`final`，如果定义为`final`该类就不能被继承，这样会产生矛盾。

- 什么是内部类

  内部类就是在类的内部再定义一个类。内部类本身就是类的一个属性，与其他属性定义方式一致。

- 内部类有四种

  - 静态内部类
    - 调用方式：`new 外部类.静态内部类()`
  - 成员内部类
    - 调用方式：`外部实例类.new 内部类()`
  - 局部内部类
    - 调用方式：`new 内部类`
  - 匿名内部类
    - 调用方式：`new 类名{ //匿名内部类实现部分  }`

- 内部类的优点

  - 内部类可以访问创建它的外部类对象的所有内容，包括私有数据。
  - 内部类不为同一个包中的其他类所见，具有良好的封装性
  - 内部类有效的实现了“多重继承”
  - 匿名内部类可以方便的实现回调。

- 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须加上`final`

  这是因为声明周期不一致导致的，局部变量直接存储再栈中，当方法执行结束后，非`final`的局部变量就会被销毁，而局部内部类对局部变量的引用仍然存在，如果局部内部类要调用局部变量时，就会出错。加上`final`之后，可以确保局部内部类使用的变量与外层的局部变量分开，解决了这个问题。

- hashcode和equals

  - `hashcode`一样，两个对象并不一定相等。

- `hashcode()`的作用的获取哈希码。实际返回的是一个`int`型整数，这个哈希码的作用是确定该对象在哈希表中的索引位置。比如往`HashSet`中添加元素中，首先会先计算添加对象的`hashcode`，也就是插入的位置，没有相应的`hashcode`，那么就可以认为对象没有重复出现，如果这个`hashcode`已经存在了，就会调用`equals`方法来判断是否真的一样。

- Java中只有值传递。

- JDK中常用的包

  - `java.lang`
  - `java.util`
  - `java.nio`
  - `java.net`
  - `java.sql`

- `javax`一开始只是`java API`的扩展，后来称为标准API的一部分。



- Java中的I/O分类
  - 按照流向分类：输入流，输出流
  - 按照操作单元分类：字节流，字符流
  - 按照流的角色划分：节点流，处理流



- `InputStream`，`OutputStream`是字节输入输出流
- `Reader`，`Writer`是字符输入输出流



- BIO、NIO、AIO分别是什么
  - `BIO`是同步阻塞IO，简单方便，并发能力低
  - `NIO`是同步非阻塞IO，传统IO的升级，客户端和服务端使用`Channel`进行通信，实现了多路复用。
  - `AIO`是异步非阻塞IO，基于事件和回调机制。



- 文件类常用的方法
  - `Files.exists()`检测文件路径是否存在
  - `Files.createFile()`创建文件
  - `Files.createDictory()`创建文件夹
  - `Files.delete()`删除文件
  - `Files.copy()`复制文件
  - `Files.move()`移动文件
  - `Files.size()`查看文件个数
  - `Files.read()`读取文件
  - `Files.write()`写入文件



- 什么是反射

  反射是在运行过程中，

  对任意一个类，都能知道这个类所具有的属性和方法；

  对任意一个对象，都能够调用它的任意一个方法和属性

  这种动态获取的信息即动态调用对象的方法的功能称为Java语言的反射机制。

- 反射的优点：运行期间判断类型，动态加载类，提高代码灵活度。

  反射的缺点：反射相当于一系列解释操作，通知JVM要做的事情，性能要比直接的Java代码慢的多。

- 获取反射的三种方式

  - 通过`new`对象实现反射机制
  - 通过路径实现反射机制
  - 通过类名实现反射机制

  ```java
  public class Demo {
      public static void main(String[] args) throws ClassNotFoundException {
          Person person = new Person();
          Class obj1 = person.getClass();
          System.out.println(">>> " + obj1.getName());
  
          Class obj2 = Class.forName("tempuse.t3.Person");
          System.out.println(">>> " + obj2.getName());
  
          Class obj3 = Person.class;
          System.out.println(">>> " + obj3.getName());
      }
  }
  ```

  

  

  

  

  

  

  

  

  

  